// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Nutzer des Systems (Kassierer, Admins, etc.) 
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String
  password  String // Hashed! 
  role      Role     @default(CASHIER)
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationen 
  transactions      Transaction[]
  auditLogs         AuditLog[]
  sessions          Session[]
  Invoice           Invoice[]
  // --- GEÄNDERT ---
  // Verweist jetzt auf das neue Modell
  purchaseDocuments PurchaseDocument[]
}

// Kunden mit Guthaben-Konto 
model Customer {
  id              String           @id @default(uuid())
  name            String
  nickname        String?
  balance         Decimal          @default(0) @db.Decimal(10, 2)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  gender          Gender?          @default(OTHER)
  lastActivity    DateTime         @default(now())

  // Relationen 
  transactions    Transaction[]
  accountTopUps   AccountTopUp[]
  highscorePoints HighscoreEntry[]
  invoices        Invoice[]
}

// Artikel/Produkte 
model Article {
  id                 String  @id @default(uuid())
  name               String
  price              Decimal @db.Decimal(10, 2)
  stock              Decimal @default(0) @db.Decimal(10, 2) // Geändert zu Decimal
  minStock           Decimal @default(0) @db.Decimal(10, 2) // Geändert zu Decimal
  unit               String  @default("Stück") // Verkaufseinheit (z.B. "Flasche")
  category           String
  imageUrl           String?
  active             Boolean @default(true)
  countsForHighscore Boolean @default(true) // Für Highscore-Konfiguration 
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  
  // NEU: Mehrere Bildgrößen
  imageThumbnail     String? // 150x150
  imageSmall         String? // 300x300
  imageMedium        String? // 600x600
  imageLarge         String? // 1200x1200
  
  // Umrechnungsfaktoren für Einkauf
  purchaseUnit       String?  @default("Kiste") // Einkaufseinheit (z.B. "Kiste")
  unitsPerPurchase   Decimal? @db.Decimal(10, 2) @default(20) // z.B. 6 Flaschen pro Kiste

  // Relationen 
  transactionItems TransactionItem[]
  stockMovements   StockMovement[]
  invoiceItems     InvoiceItem[]
  // --- GEÄNDERT ---
  // Verweist jetzt auf das neue Modell
  purchaseDocumentItems PurchaseDocumentItem[]
}

// Verkaufstransaktion 
model Transaction {
  id          String          @id @default(uuid())
  type        TransactionType
  paymentMethod PaymentMethod
  totalAmount Decimal         @db.Decimal(10, 2)
  cancelled   Boolean         @default(false)
  cancelledAt DateTime?
  cancelledBy String? // User ID 
  instanceId  String? // Multi-Instanz-Support 
  createdAt   DateTime        @default(now())

  // Relationen 
  userId     String
  user       User            @relation(fields: [userId], references: [id])
  customerId String?
  customer   Customer?       @relation(fields: [customerId], references: [id])
  items      TransactionItem[]

  // Für Storno-Verknüpfung 
  originalTransactionId String?
  originalTransaction   Transaction?  @relation("CancelledTransaction", fields: [originalTransactionId], references: [id])
  cancelledTransactions Transaction[] @relation("CancelledTransaction")
  Invoice               Invoice?      @relation(fields: [invoiceId], references: [id])
  invoiceId             String?
}

// Einzelne Positionen einer Transaktion 
model TransactionItem {
  id            String  @id @default(uuid())
  quantity      Int
  pricePerUnit  Decimal @db.Decimal(10, 2)
  totalPrice    Decimal @db.Decimal(10, 2)

  // Relationen 
  transactionId String
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  articleId     String
  article       Article     @relation(fields: [articleId], references: [id])
}

// Kundenkonto-Aufladungen 
model AccountTopUp {
  id        String      @id @default(uuid())
  amount    Decimal     @db.Decimal(10, 2)
  method    TopUpMethod
  reference String? // z.B. Überweisungsreferenz 
  createdAt DateTime    @default(now())

  // Relationen 
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id])
}

// Bestandsbewegungen (Wareneingang, Inventur, etc.) 
model StockMovement {
  id        String            @id @default(uuid())
  type      StockMovementType
  quantity  Decimal           @db.Decimal(10, 2) // WICHTIG: Muss Decimal sein
  reason    String?
  createdAt DateTime          @default(now())

  // Relationen 
  articleId String
  article   Article @relation(fields: [articleId], references: [id])
}

// Audit-Log für alle Änderungen 
model AuditLog {
  id         String   @id @default(uuid())
  action     String // z.B. "CREATE_ARTICLE", "CANCEL_TRANSACTION" 
  entityType String // z.B. "Article", "Transaction" 
  entityId   String
  changes    Json? // JSON mit Änderungen 
  createdAt  DateTime @default(now())

  // Relationen 
  userId String
  user   User   @relation(fields: [userId], references: [id])
}

// Sessions für JWT-Token-Management 
model Session {
  id           String   @id @default(uuid())
  token        String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  // Relationen 
  userId String
  user   User   @relation(fields: [userId], references: [id])
}

// Highscore-Einträge 
model HighscoreEntry {
  id         String        @id @default(uuid())
  type       HighscoreType
  value      Decimal       @db.Decimal(10, 2) // Euro oder Anzahl 
  date       DateTime      @default(now())

  // Relationen 
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id])

  @@index([type, date])
}

// ENUMS 
enum Role {
  ADMIN
  CASHIER
  ACCOUNTANT
}

enum TransactionType {
  SALE
  REFUND
  EXPIRED
  OWNER_USE
}

enum PaymentMethod {
  CASH
  ACCOUNT
  INVOICE
  TRANSFER
}

enum TopUpMethod {
  CASH
  TRANSFER
}

enum StockMovementType {
  DELIVERY // Wareneingang 
  INVENTORY // Inventur 
  CORRECTION // Korrektur 
  SALE // Verkauf (automatisch) 
  EXPIRED // Abgelaufen
  OWNER_USE // Eigenverbrauch
}

enum HighscoreType {
  DAILY_AMOUNT // Tagesumsatz in Euro 
  DAILY_COUNT // Tagesanzahl 
  YEARLY_AMOUNT // Jahresumsatz in Euro 
  YEARLY_COUNT // Jahresanzahl 
}

// --- NEUES, KONSOLIDIERTES EINKAUFSMODELL ---
// Ersetzt Purchase, PurchaseItem, DeliveryNote, DeliveryNoteItem

// Definiert, ob ein Beleg eine Rechnung (mit Geld) 
// oder ein Lieferschein (nur Ware) ist.
enum PurchaseDocumentType {
  RECHNUNG
  LIEFERSCHEIN
}

// Ein Beleg kann entweder eine Rechnung oder ein Lieferschein sein.
model PurchaseDocument {
  id             String               @id @default(uuid())

  // KERNFELD: RECHNUNG oder LIEFERSCHEIN
  type           PurchaseDocumentType

  // Gemeinsame Daten
  documentNumber String               @unique // "RE2025-11" oder "LS2025-3"
  supplier       String
  documentDate   DateTime // Datum des Belegs
  nachweisUrl    String? // URL zum Scan (PDF/Bild)
  description    String?
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt

  // Finanzdaten (nur relevant für type = RECHNUNG)
  totalAmount    Decimal?             @db.Decimal(10, 2) // Bei LIEFERSCHEIN = null
  paid           Boolean              @default(false)
  paidAt         DateTime?
  paymentMethod  PaymentMethod? // Nimmt das bestehende Enum
  dueDate        DateTime?

  // Wareneingangsdaten (Positionen)
  // Ein Lieferschein MUSS items haben.
  // Eine RECHNUNG KANN items haben (beim Sofortkauf).
  // Eine Sammelrechnung hat KEINE items (da diese bei den Lieferscheinen liegen).
  items          PurchaseDocumentItem[]

  // --- DIE SCHLÜSSEL-VERKNÜPFUNG (1:N) ---

  // Wenn dies ein Lieferschein ist (type=LIEFERSCHEIN), 
  // kann er EINER Rechnung zugewiesen werden.
  rechnungId     String?
  rechnung       PurchaseDocument?    @relation("RechnungZuLieferscheinen", fields: [rechnungId], references: [id], onDelete: SetNull)

  // Wenn dies eine Rechnung ist (type=RECHNUNG), 
  // kann sie MEHRERE Lieferscheine haben.
  lieferscheine  PurchaseDocument[]   @relation("RechnungZuLieferscheinen")

  // Relationen
  userId         String
  user           User                 @relation(fields: [userId], references: [id])

  @@index([type])
  @@index([supplier])
  @@index([rechnungId])
}

// Positionen für einen Lieferschein oder einen Sofortkauf
model PurchaseDocumentItem {
  id          String  @id @default(uuid())
  description String // z.B. "Chardonnay"
  quantity    Decimal @db.Decimal(10, 2) // Die *FINALE* Menge (z.B. 15 Flaschen)
  unit        String // Die *FINALE* Einheit (z.B. "Flasche")

  // Info für die UI (wie wurde es eingegeben?)
  purchaseUnit         String? // z.B. "Kiste"
  purchaseUnitQuantity Decimal? @db.Decimal(10, 2) // z.B. 2
  baseUnit             String? // z.B. "Flasche"
  baseUnitQuantity     Decimal? @db.Decimal(10, 2) // z.B. 3

  // Finanzdaten (nur relevant bei Sofortkauf, sonst 0)
  pricePerUnit Decimal @db.Decimal(10, 2) @default(0) // Preis pro *FINALE* Einheit
  totalPrice   Decimal @db.Decimal(10, 2) @default(0)

  // Relationen
  documentId String
  document   PurchaseDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  articleId  String?
  article    Article?         @relation(fields: [articleId], references: [id], onDelete: SetNull)
}


// Neues Model für Ausgangsrechnungen
model Invoice {
  id              String        @id @default(uuid())
  invoiceNumber   String        @unique
  customerName    String
  customerAddress String?
  description     String?
  totalAmount     Decimal       @db.Decimal(10, 2)
  taxRate         Decimal       @default(19) @db.Decimal(5, 2)
  status          InvoiceStatus @default(DRAFT)
  paidAt          DateTime?
  dueDate         DateTime
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relationen
  userId          String
  user            User          @relation(fields: [userId], references: [id])
  customerId      String? // Optional, falls registrierter Kunde
  customer        Customer?     @relation(fields: [customerId], references: [id])
  items           InvoiceItem[]
  transactions    Transaction[] // Verknüpfung zu Zahlungen
}

// Rechnungspositionen
model InvoiceItem {
  id           String  @id @default(uuid())
  description  String
  quantity     Decimal @db.Decimal(10, 2) // Ist bereits Decimal
  pricePerUnit Decimal @db.Decimal(10, 2)
  totalPrice   Decimal @db.Decimal(10, 2)

  // Relationen
  invoiceId String
  invoice   Invoice  @relation(fields: [invoiceId], references: [id])
  articleId String?
  article   Article? @relation(fields: [articleId], references: [id])
}

// Neue Enums
enum Gender {
  MALE
  FEMALE
  OTHER
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  CANCELLED
}

// prisma/schema.prisma (Ergänzung)
model FiscalYear {
  id           String   @id @default(cuid())
  name         String
  startDate    DateTime
  endDate      DateTime
  closed       Boolean  @default(false)
  report       YearEndReport?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model YearEndReport {
  id               String   @id @default(cuid())
  fiscalYearId     String   @unique
  fiscalYear       FiscalYear @relation(fields: [fiscalYearId], references: [id])
  // Finanz-Zusammenfassung
  incomeTotal      Decimal   @default(0)
  expensesTotal    Decimal   @default(0)
  profit           Decimal   @default(0)
  // Bestände / Guthaben zum Stichtag
  cashOnHand       Decimal   @default(0)   // Barkasse (manuell eingegeben)
  bankAccountsJson Json      @default("[]")// [{name, iban?, balance}]
  guestBalance     Decimal   @default(0)   // Summe Customer.balance
  // Rohdaten-Snapshots
  inventorySystem  Json      @default("[]")// [{articleId,name,systemStock,unit}]
  inventoryPhysical Json     @default("[]")// [{articleId,name,physicalStock,unit}]
  inventoryDiff    Json      @default("[]")// [{articleId,name,diff,unit}]
  createdAt        DateTime  @default(now())
}

// Werbe-Slides für Digital Signage
model AdSlide {
  id          String           @id @default(uuid())
  imageUrl    String
  duration    Int              @default(10) // Sekunden
  transition  AdTransitionType @default(FADE)
  order       Int              @default(0)
  active      Boolean          @default(true)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
}

enum AdTransitionType {
  FADE
  SLIDE
  ZOOM
  NONE
}
